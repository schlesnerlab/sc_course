---
title: "Functional Analyses"
output:
  pdf_document:
    toc: true
    toc_depth: '2'
  html_document:
    theme: spacelab
    highlight: pygments
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 2
    df_print: paged
---

# Setup

<link rel="stylesheet" href="headers.css">

```{r setup}
# .libPaths(new = "/scratch/local/rseurat/pkg-lib-4.1.3")

suppressMessages({
  library(decoupleR)
  library(tidyverse)
  library(Seurat)
  library(pheatmap)
  library(SCpubr)
})


set.seed(8211673)

knitr::opts_chunk$set(echo = TRUE, format = TRUE, out.width = "100%")


options(
  parallelly.fork.enable = FALSE,
  future.globals.maxSize = 8 * 1024^2 * 1000
)

plan("multicore", workers = 8)
```

```{r useful-information, echo=FALSE}
cat("work directory: ", getwd())
cat("\n")
cat("library path(s): ", .libPaths())
```

# Load Data

We'll be working with the data from our past notebook ("First steps"), let's quickly re-load and re-process again:

```{r first_steps, warning=FALSE, eval = FALSE}
pbmc <- Read10X(data.dir = "./datasets/filtered_gene_bc_matrices/hg19/") %>%
  CreateSeuratObject(counts = ., project = "pbmc3k", min.cells = 3, min.features = 200)

pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")

pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)

pbmc <- NormalizeData(pbmc, verbose = FALSE)

pbmc <- FindVariableFeatures(pbmc, verbose = FALSE)

pbmc <- ScaleData(pbmc, features = rownames(pbmc), verbose = FALSE)

pbmc <- RunPCA(pbmc, features = VariableFeatures(pbmc), verbose = FALSE)

pbmc <- FindNeighbors(pbmc, dims = seq_len(10), verbose = FALSE)

pbmc <- FindClusters(pbmc, resolution = 0.5, verbose = FALSE)

pbmc <- RunUMAP(pbmc, dims = seq_len(10), verbose = FALSE)
```

Next, we do our between-clusters DE analysis:

```{r de_steps}
sample <- readRDS("../sample_processed.RDS")
markers.between.clusters <- FindAllMarkers(
  sample,
  test.use = "wilcox",
  logfc.threshold = 0.5,
  min.pct = 0.3,
  only.pos = TRUE,
  densify = TRUE
)
```

# Functional Enrichment Analysis

These methods have first been used for microarrays, and aim to draw conclusions ranked gene list from RNAseq experiments, scRNA, or any other OMICS screen.
There are a number of tools and approaches - here we will focus only one common and practical approach.

For more information, see: [clusterProfiler](https://yulab-smu.top/biomedical-knowledge-mining-book/clusterProfiler-dplyr.html).

The aim is to draw conclusions as to what's the functional implications that we may be able to derive given a list of genes.
To this end, we'd start with such list and then consult databases for the annotations.
With this data, we can come up with scores to measure level of association.
A gene set is an unordered collection of genes that are functionally related.

## Gene Ontology

[GO Terms](http://www.geneontology.org/) are semantic representations in a curated database that defines concepts/classes used to describe gene function, and relationships between these concepts.
GO terms are organized in a directed acyclic graph, where edges between terms represent parent-child relationship.
It classifies functions along three aspects:

-   MF: Molecular Function, molecular activities of gene products
-   CC: Cellular Compartment, where gene products are active
-   BP: Biological Processes, pathways and larger processes made up of the activities of multiple gene products

<!-- rbioapi::rba_reactome_analysis(input = genes.1, p_value = 0.1) -->

## enrichR

The package is already loaded.
But we need to select which databases to connect.
There are more than 200 databases available, you can get a data frame with details of these using `listEnrichrDbs()`.
For this and the following to work you need a working internet connection.

```{r dbs}
decoupleR::get_resource("PanglaoDB") -> panglao_data

panglao_data %>% dplyr::mutate(human = as.logical(human)) %>%dplyr::filter(human) %>% dplyr::mutate(canonical_marker = as.logical(canonical_marker)) %>% dplyr::filter(canonical_marker) %>% dplyr::filter("human_sensitivity" > 0.5) -> panglao_human_marker

```

```{r enrichr}
mat <- as.matrix(sample@assays$RNA$data)
panglao_human_marker<- panglao_human_marker[!duplicated(panglao_human_marker[,c("cell_type", "genesymbol")]),]
ora_enrich <- decoupleR::run_aucell(
    mat=mat,
    network=panglao_human_marker,
    .source='cell_type',
    .target='genesymbol',
    minsize=3,
)

sample[["panglao_aucell"]] <-   ora_enrich %>%
  pivot_wider(id_cols = 'source', names_from = 'condition',
              values_from = 'score') %>%
  column_to_rownames('source') %>%
  Seurat::CreateAssayObject(.)
# Scale the data
sample <- ScaleData(sample, assay = "panglao_aucell")
sample@assays$panglao_ora$data <- sample@assays$panglao_ora$scale.data
```

```{r}
n_tfs <- 3
# Extract activities from object as a long dataframe
df <- t(as.matrix(sample@assays$panglao_aucell@scale.data)) %>%
  as.data.frame() %>%
  mutate(cluster = Idents(sample)) %>%
  pivot_longer(cols = -cluster, names_to = "source", values_to = "score") %>%
  group_by(cluster, source) %>%
  summarise(mean = mean(score))

top_3_cell_types <- df %>%
    group_by(cluster) %>%
    top_n(3, mean)

all_top_cell_types <- top_3_cell_types %>% pull(source) %>% unique()

top_acts_mat <- df %>%
  filter(source %in% all_top_cell_types) %>%
  pivot_wider(id_cols = 'cluster', names_from = 'source',
              values_from = 'mean') %>%
  column_to_rownames('cluster') %>%
  as.matrix()

# Choose color palette
palette_length = 100
my_color = colorRampPalette(c("Darkblue", "white","red"))(palette_length)

my_breaks <- c(seq(-3, 0, length.out=ceiling(palette_length/2) + 1),
               seq(0.05, 3, length.out=floor(palette_length/2)))

# Plot
pheatmap(top_acts_mat, border_color = NA,scale = "row", color=my_color, breaks = my_breaks)
```

> âŒ¨ðŸ”¥ Exercise(s):
>
> 1.  Understand the format and interpret the output `result.1`.
> 2.  What is the most significantly enriched molecular function? which genes are the base for it?
> 3.  Would you get the same result if you changed the number of marker genes in the input? Try it out.

We can also produce nice graphical summaries:

```{r}

net <- get_progeny(organism = 'human', top = 500)
net

mat <- as.matrix(sample@assays$RNA@data)

# Run mlm
acts <- run_mlm(mat=mat, network =net, .source='source', .target='target',
                .mor='weight', minsize = 5)
acts

```

```{r}
# Extract mlm and store it in pathwaysmlm in data
sample[['pathwaysmlm']] <- acts %>%
  pivot_wider(id_cols = 'source', names_from = 'condition',
              values_from = 'score') %>%
  column_to_rownames('source') %>%
  Seurat::CreateAssayObject(.)

# Change assay
DefaultAssay(object = sample) <- "pathwaysmlm"

# Scale the data
sample <- ScaleData(sample, assay = "pathwaysmlm")
sample@assays$pathwaysmlm@data <- sample@assays$pathwaysmlm@scale.data
```

```{r}
p1 <- DimPlot(sample, reduction = "umap", label = TRUE, pt.size = 0.5) + 
  NoLegend() + ggtitle('Cell types')
p2 <- (do_NebulosaPlot(sample, features = c("MAPK"),) & 
  scale_colour_gradient2(low = 'blue', mid = 'white', high = 'red')) +
  ggtitle('MAPK activity')
p1 | p2

```
### Compare with results from Publication

```{r, fig.width =12, fig.height=12}
excel_data <- readxl::read_excel("../1-s2.0-S2666379123004263-mmc3.xlsx", sheet = "OD top50 markers",skip = 1)

excel_data %>% pivot_longer(cols = everything()) -> excel_long

acts_paper <- decoupleR::run_aucell(mat, network = excel_long, .source = "name", .target = "value")

# Extract mlm and store it in pathwaysmlm in data
sample[['paper_aucell']] <- acts_paper %>%
  pivot_wider(id_cols = 'source', names_from = 'condition',
              values_from = 'score') %>%
  column_to_rownames('source') %>%
  Seurat::CreateAssayObject(.)

SCpubr::do_ViolinPlot(sample, features = c("OPC-like", "Endothelial"), assay = "paper_aucell")

SCpubr::do_FeaturePlot(sample, assay = "paper_aucell", features = colnames(excel_data),legend.position = "none",individual.captions = colnames(excel_data))
                       
```

